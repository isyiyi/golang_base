# 记录一些容易出错的地方

1. 安装完成之后要配置GOROOT、PATH环境变量
2. 设置GO111MODULE、GOPROXY变量，命令为`go env -w GO111MODULE=on`，因为go默认使用GOPATH的方式寻找包，如果不设置GOMODULE的方式导包会出错
3. 建立新项目之后要使用`go mod init xxx` 初始化包名为xxx
4. 导包时路径从第3步初始化的包开始写即可（仅限于从子包中向main包导入），无需写绝对地址（写绝对地址会出错）


**`_`空标识符用于语法上需要，而逻辑上不需要的地方。因为golang语法上不允许存在未使用的变量声明，而有时逻辑上可能并不需要这个变量，因此空标识符可以解决这个问题**

5. 短变量通常用于函数内部和if、for等初始化的时候，在包级向量初始化的地方不被允许
6. 在打开文件时，如果在子包中定义的文件名，应该将路径写成从main.go所在的位置到文件所在的位置，而不是子包文件所在的位置相对于文件所在的位置
如：子包路径为：
```text
test(directory)
	main.go
	sonPackage
		fileOpen.go
		data1.txt
		data2.txt
```

**如果在fileopen.go路径写为（./data1.txt,./data2.txt）将会报错文件找不到，因为在执行时以main.go为根路径，所以文件路径应写为（sonPackage/data1.txt,sonPackage/data2.txt），尽管文件和fileOpen.go在同一目录下**

switch语句不同于C语言中，一个case执行完之后默认有一个break不往下执行，如果非得向下执行可以使用fallthrough击穿条件。并且case条件也不一定是固定的字面量，可以是布尔表达式。switch后不一定非得跟字面量，类似于if和else，如：
```golang
func test(x int) {
	switch {
	case x > 0 :
		xxxxxxxx
	case x == 0 :
		xxxxxxxx
	default :
		xxxxxxxx
	}
}
```

**go语言中的方法和函数不是一种，方法是关联了命名类型的函数**

7. 指针类型所占的内存大小与指针指向的数据类型无关，至于操作系统的位数有关，32位的为4个字节，64位的为8个字节。因为无论指向的数据是什么类型，指针终究指向的还是一个内存地址，内存地址至于操作系统有关
8. 每个变量都有地址，指针变量存储的是变量的地址，它自己也有地址，存储指针变量地址的变量叫做指针的指针
9. 使用`new(Type)`创建并返回的是Type类型的指针
10. 函数内部声明的任何东西都只能在函数内部使用（除了闭包可以操作外），包级别声明的东西在同一个包的所有.go源文件都可以访问，包级别声明的东西首字母大小写决定了其他包导入这个包时是否能够访问
11. 在局部函数中通常使用短变量声明，var关键字是为那些变量声明之后择机再赋值的情景准备的，或者那些声明的初始表达式类型与想要的类型不同时，如：
```golang
// 想要的float64与100初始的int类型并不相同，使用短变量声明达不到要求
var num float64 = 100

var s string
......
// 在声明s时并不着急使用，之后再赋值
if expression {
	s = xxxxx
}
```

12. 短变量声明表达式左边的变量并不一定都是未被声明过的，但至少有一个是未被声明过的。已经被声明的变量默认为赋值，如果所有的变量都已经被声明过，请将`:=`改为`=`
13. 每一个聚合类型变量的组成（结构体的成员、数组和切片的元素）都是变量，所以他们都有各自的地址
14. Golang中的参数传递都是值传递（除了切片、channel、map），即使是指针也是将实参指针的值（一个地址）传递给形参

