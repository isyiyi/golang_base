# 记录一些容易出错的地方

1. 安装完成之后要配置GOROOT、PATH环境变量
2. 设置GO111MODULE、GOPROXY变量，命令为`go env -w GO111MODULE=on`，因为go默认使用GOPATH的方式寻找包，如果不设置GOMODULE的方式导包会出错
3. 建立新项目之后要使用`go mod init xxx` 初始化包名为xxx
4. 导包时路径从第3步初始化的包开始写即可（仅限于从子包中向main包导入），无需写绝对地址（写绝对地址会出错）


**`_`空标识符用于语法上需要，而逻辑上不需要的地方。因为golang语法上不允许存在未使用的变量声明，而有时逻辑上可能并不需要这个变量，因此空标识符可以解决这个问题**

5. 短变量通常用于函数内部和if、for等初始化的时候，在包级向量初始化的地方不被允许
6. 在打开文件时，如果在子包中定义的文件名，应该将路径写成从main.go所在的位置到文件所在的位置，而不是子包文件所在的位置相对于文件所在的位置
如：子包路径为：
```text
test(directory)
	main.go
	sonPackage
		fileOpen.go
		data1.txt
		data2.txt
```

**如果在fileopen.go路径写为（./data1.txt,./data2.txt）将会报错文件找不到，因为在执行时以main.go为根路径，所以文件路径应写为（sonPackage/data1.txt,sonPackage/data2.txt），尽管文件和fileOpen.go在同一目录下**

switch语句不同于C语言中，一个case执行完之后默认有一个break不往下执行，如果非得向下执行可以使用fallthrough击穿条件。并且case条件也不一定是固定的字面量，可以是布尔表达式。switch后不一定非得跟字面量，类似于if和else，如：
```golang
func test(x int) {
	switch {
	case x > 0 :
		xxxxxxxx
	case x == 0 :
		xxxxxxxx
	default :
		xxxxxxxx
	}
}
```

**go语言中的方法和函数不是一种，方法是关联了命名类型的函数**

7. 指针类型所占的内存大小与指针指向的数据类型无关，只与操作系统的位数有关，32位的为4个字节，64位的为8个字节。因为无论指向的数据是什么类型，指针终究指向的还是一个内存地址，内存地址只与操作系统有关
8. 每个变量都有地址，指针变量存储的是变量的地址，它自己也有地址，存储指针变量地址的变量叫做指针的指针
9. 使用`new(Type)`创建并返回的是Type类型的指针
10. 函数内部声明的任何东西都只能在函数内部使用（除了闭包可以操作外），包级别声明的东西在同一个包的所有.go源文件都可以访问，包级别声明的东西首字母大小写决定了其他包导入这个包时是否能够访问
11. 在局部函数中通常使用短变量声明，var关键字是为那些变量声明之后择机再赋值的情景准备的，或者那些声明的初始表达式类型与想要的类型不同时，如：
```golang
// 想要的float64与100初始的int类型并不相同，使用短变量声明达不到要求
var num float64 = 100

var s string
......
// 在声明s时并不着急使用，之后再赋值
if expression {
	s = xxxxx
}
```

12. 短变量声明表达式左边的变量并不一定都是未被声明过的，但至少有一个是未被声明过的。已经被声明的变量默认为赋值，如果所有的变量都已经被声明过，请将`:=`改为`=`
13. 每一个聚合类型变量的组成（结构体的成员、数组和切片的元素）都是变量，所以他们都有各自的地址
14. Golang中的参数传递都是值传递（除了切片、channel、map），即使是指针也是将实参指针的值（一个地址）传递给形参
15. 通过type可以对已有的类型进行重新命名，在golang中，可赋值性表现为=两边的类型严格相同，所以进行重命名的类型之间不具有可赋值性，所以也不能进行任何运算，但是底层相同的两种类型之间可以进行显式的类型转换
16. 包的初始化顺序（根据导入包的顺序，自下而上，确保被导入包在当前包初始化之前被初始化）
	1. 初始化包级别的变量
	2. init函数，一个包中每个.go源文件都可以有多个init函数
17. 生命周期和作用域是两个截然不同的概念，生命周期是一个运行时概念，而作用域是一个编译时概念
18. 当局部变量和包级别变量重名时，会优先使用局部变量
19. 一个大括号围起来的一个语句序列叫做语法块。语法块内部声明的变量对外部不可见，但是对内部却是可见的。所以可以有下列情况：
```golang
// 虽然在短短的几行代码中，3次声明了x变量，但是并没有错误，它们3个处于不同的语法块中
// 每次声明并初始化时都要使用右边的表达式，而x在当时却未声明，所以=右边实际使用的是外层的x，而同级语法块内部使用的是刚声明的x
x := "hello!"
for i := 0; i < len(x); i++ {
	x := x[i]
	if x != '!' {
		x := x + 'A' - 'a'
		fmt.Printf("%c\n", x)
	}
}
``` 
20. if、switch、for等条件控制语句会创建一个隐式语法块，这个隐式语法块中的局部变量在整个控制结构中都能够使用，如：
```golang
if x := f(); x > 3 {
	xxxx
}else {
	// 无论在if还是在else中x都可以使用
	xxxx
}

// 同理，switch结构也可以

switch x := f(); x {
case x > 90 :
	xxxx
case x < 90 :
	xxxx
default :
	// 无论在哪一个case，x都可以使用
	xxxx
}
// 更有甚者，如下方所示

if x := f(); x > 3 {
	xxxxx
} else if y := g(x); x == y { // 使用if隐式语法域中的x作为参数，产生新的变量y
	xxxxx
	// 在这个分支以下的所有分支都可以使用y，但是在这个分支以上的分支不能使用y
}

```

21. 包级别的函数和常量、变量等声明没有先后顺序，前边的可以调用后边的
22. golang的数据类型
	1. 基础类型
		+ 数字
		+ 字符串
		+ 布尔类型
	2. 聚合类型
		+ 结构体
		+ 数组
	3. 引用类型
		+ 切片
		+ 字典
		+ 指针
		+ 通道
	4. 接口类型
		+ 接口
golang的整型分为`int8 int16 int32 int64 uint8 uint16 uint32 uint64 int uint`，其中int和uint对应于不同的硬件平台使用的大小也不同，等于该平台上运算效率最高的值。
rune是int32的同义词，两个名称可以互换使用，4个字节用来存储Unicode码点。
uintptr是无符号整数，用来存储指针类型，其大小并不明确，仅仅用于底层编程
int和uint的大小并不明确，尽管大多时候大小都等于int32，但是运算时必须进行显式的类型转换

**golang中空结构体是不占用内存的，struct{}在内存中占用为0，初始化时可以使用空结构体；但是，使用空结构体进行初始化并不一定是节省内存，事实上内存节省也很有限，主要的意义在于说明我们根本不关心结构体的值**

**原理**：空结构体就是没有内存大小的结构体，所有被定义的空结构体都指向`zerobase`变量的地址，所以所有空结构体变量的值是一样的。struct{}本身就是结构体类型，只不过通过type对它进行重命名为其他类型，如：`type Student struct{}`

**使用**：空结构体与channel结合进行信号同步，只关心是否发送了这个值，而对这个值本身是谁并不感兴趣；空结构体与map结合进行key存在检测，此时的空结构体只是作为标记存在。

23. 结构体变量初始化时，如果不对内部变量做任何赋值，默认为对应类型的零值
24. golang中取模运算结果的符号与被除数一致，并且只能用于整数，如：`-9 % -5 = -4  ||  5 % -2 = 1`
25. 整数相除得到的结果会舍弃小数位
26. `& | ^ &^`四个位运算符，都是逐位独立进行运算，`^`可作为一元运算符，意为取反
	+ `&^` 位清空，如：`a &^ b` 意为如果b的二进制位为1时，a对应于的位置将置为0
27. 浮点数转为整数时，正数向下取整，负数向上取整
28. golang中可以直接将一个int类型整数定义为八进制或十六进制，八进制用`0`开头，十六进制用`0x`开头
29. 如果结果是无穷大，那么通过math.NaN()可以得到一个数学意义上的无意义的计算结果。但是这个结果是不可比较的，因为它与自己都可能不相等。只能通过math.isNaN()来得到这是不是一个无意义的值 
30. golang中可以直接通过在表达式后加i来创建一个复数，或者通过complex(real, imag)指定实部和虚部来创建复数，real()和imag()函数可以得到一个复数的实部和虚部
31. golang的逻辑与和或具有短路行为，即左边能够确定逻辑表达式的结果之后右边将不运算
32. 1和0与true和false没有对应关系，必须显式转换(写函数判断，不是显式类型转换)
33. 当string类型的数据存储的是英文字符时，使用len()和遍历都是正常的；但是一旦存储的是非ASCII码字符，因为一个Unicode字符占用空间可能是3-4个字节，所以len()和遍历都会出现乱码；所以需要使用[]rune()对字符串序列进行强制类型转换，生成Unicode码点序列；如果使用range进行遍历的话，golang会默认使用utf-8隐式解码的方式遍历
34. 字符串值自初始化之后将永不可变，再次赋值只是将新的字符串值赋值给这个变量，所以字符串本身的值不能通过索引来更改
35. Unicode官网上的字符可以直接赋值给string类型，分为`\u`和`\U`开头两种，`\u`的为2个字节4个二进制位，`\U`的为4个字节8个二进制位
36. 常量声明时，如果后一个没有显式赋值，将会自动继承上一个常量的值。使用iota语法之后，iota从0开始逐个赋值，如果显式给某个常量赋值，iota语法仍然会隐式递增。如：
```golang
const (
	a = 10
	b
	c
	d = 11
)
// a = b = c = 10 , d = 11

const (
	a = iota
	b	 // iota递增，b = 1
	c = 10
	d	 // d = 10，没有显式赋值，将会自动继承上一个常量的值
	e = iota // e = 4，尽管iota被中断了，但是仍在隐式增长
)
// a = 0 , b = 1 , c = 10 = d , e = 4

const (
	a = 1 + iota
	b	 // =右边的表达式会随着iota语法被一并带到下一个常量的赋值中
	c
)
// a = 1 , b = 2 , c = 3
```
37. 纯纯常量（字符串值或整数值、true等）通常是无类型的，但是一旦变量明确了数据类型且把常量值赋值给了变量，将会被隐式转换为指定的类型
38. 数组类型的元素如果是可比较的，那么数组就是可比较的，但前提是两个数组的类型相同，数组类型为[len]type，如果len不同，那么两个数组的类型就不同
39. 如果初始化数组元素时，通过指定元素位置的方式初始化，那么元素初始化的顺序就可以随便并且有的位置可以不初始化，没有被初始化的位置元素默认为对应类型的零值
40. 切片是不能被比较的，因为切片引用的是底层数组，在同一时间可能会有别的协程在改数据。并且由于map的键必须是可被比较的，因为键要确保在map的整个生命周期内都是不可变的（如果发生改变，散列表将找不到原先的位置），所以map的键不能是切片类型
41. 对于接收可变参数的位置，可以直接传入切片，但是要在后面加上`...`进行解包
```golang
func f(x... int) {
	xxxx
}

var nums = [] int {xxx }
f(nums...)
```
42. map的值不是一个变量，不能对其取地址。因为随着map长度的增加，已经被分配内存的值可能会被移动，所以地址可能在整个生命周期不是固定的
43. slice和map、chan都要进行初始化，只是声明的话，后边使用将会出错
```golang
var nums []int
nums[0] = 1	// 出错

nums = append(nums, 1)	// 编译器会自动为nums申请底层数组

var nums = []int{1}	// 正确，但此时长度和容量都是初始化元素的长度
var nums = make([]int, len, cap)	// 使用make()来初始化并指定长度和容量


var m map[string] int
m["aa"] = 90	// 出错

var m = make(map[string]int)
m["aa"] = 90	// 正确
``` 

44. 结构体初始化时，必须在{}前面加上结构体的名字，在多层嵌套的结构体也是如此，并且可以使用临时结构体
```golang
// 创建临时的结构体
var tmp = struct {
	name stirng
	age int
}{"kobe", 37}

// =================================

type Point struct {
	X int
	Y int
}

type Cricle struct {
	Point 
	Radius int
}

type Wheel struct {
	Cricle 
	Spokes int
}

var w = Wheel{
	Cricle: Cricle{
		Point: Point{
			X: 20,
			Y: 20,
		},
		Radius: 90,
		},
	Spokes: 100,
	}
var w2 = Wheel{X:20, Y:20, Radius:90, Spokes:100}	// 这种方式初始化是错误的
// 访问的时候使用w.X或者w.Cricle.Point.X都可以

```
45. 对于匿名变量的初始化不能使用直接访问的形式，必须遵循形状定义的方式来初始化
46. 无论是数组还是切片还是结构体初始化时，如果右边大括号另起一行，记着在最后一个元素的后边加上一个逗号














































