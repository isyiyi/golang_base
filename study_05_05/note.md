# 记录一些容易出错的地方

1. 安装完成之后要配置GOROOT、PATH环境变量
2. 设置GO111MODULE、GOPROXY变量，命令为`go env -w GO111MODULE=on`，因为go默认使用GOPATH的方式寻找包，如果不设置GOMODULE的方式导包会出错
3. 建立新项目之后要使用`go mod init xxx` 初始化包名为xxx
4. 导包时路径从第3步初始化的包开始写即可（仅限于从子包中向main包导入），无需写绝对地址（写绝对地址会出错）


**`_`空标识符用于语法上需要，而逻辑上不需要的地方。因为golang语法上不允许存在未使用的变量声明，而有时逻辑上可能并不需要这个变量，因此空标识符可以解决这个问题**

5. 短变量通常用于函数内部和if、for等初始化的时候，在包级向量初始化的地方不被允许
6. 在打开文件时，如果在子包中定义的文件名，应该将路径写成从main.go所在的位置到文件所在的位置，而不是子包文件所在的位置相对于文件所在的位置
如：子包路径为：
```text
test(directory)
	main.go
	sonPackage
		fileOpen.go
		data1.txt
		data2.txt
```

**如果在fileopen.go路径写为（./data1.txt,./data2.txt）将会报错文件找不到，因为在执行时以main.go为根路径，所以文件路径应写为（sonPackage/data1.txt,sonPackage/data2.txt），尽管文件和fileOpen.go在同一目录下**

switch语句不同于C语言中，一个case执行完之后默认有一个break不往下执行，如果非得向下执行可以使用fallthrough击穿条件。并且case条件也不一定是固定的字面量，可以是布尔表达式。switch后不一定非得跟字面量，类似于if和else，如：
```golang
func test(x int) {
	switch {
	case x > 0 :
		xxxxxxxx
	case x == 0 :
		xxxxxxxx
	default :
		xxxxxxxx
	}
}
```

**go语言中的方法和函数不是一种，方法是关联了命名类型的函数**

7. 指针类型所占的内存大小与指针指向的数据类型无关，至于操作系统的位数有关，32位的为4个字节，64位的为8个字节。因为无论指向的数据是什么类型，指针终究指向的还是一个内存地址，内存地址至于操作系统有关
8. 每个变量都有地址，指针变量存储的是变量的地址，它自己也有地址，存储指针变量地址的变量叫做指针的指针
9. 使用`new(Type)`创建并返回的是Type类型的指针
10. 函数内部声明的任何东西都只能在函数内部使用（除了闭包可以操作外），包级别声明的东西在同一个包的所有.go源文件都可以访问，包级别声明的东西首字母大小写决定了其他包导入这个包时是否能够访问
11. 在局部函数中通常使用短变量声明，var关键字是为那些变量声明之后择机再赋值的情景准备的，或者那些声明的初始表达式类型与想要的类型不同时，如：
```golang
// 想要的float64与100初始的int类型并不相同，使用短变量声明达不到要求
var num float64 = 100

var s string
......
// 在声明s时并不着急使用，之后再赋值
if expression {
	s = xxxxx
}
```

12. 短变量声明表达式左边的变量并不一定都是未被声明过的，但至少有一个是未被声明过的。已经被声明的变量默认为赋值，如果所有的变量都已经被声明过，请将`:=`改为`=`
13. 每一个聚合类型变量的组成（结构体的成员、数组和切片的元素）都是变量，所以他们都有各自的地址
14. Golang中的参数传递都是值传递（除了切片、channel、map），即使是指针也是将实参指针的值（一个地址）传递给形参
15. 通过type可以对已有的类型进行重新命名，在golang中，可赋值性表现为=两边的类型严格相同，所以进行重命名的类型之间不具有可赋值性，所以也不能进行任何运算，但是底层相同的两种类型之间可以进行显式的类型转换
16. 包的初始化顺序（根据导入包的顺序，自下而上，确保被导入包在当前包初始化之前被初始化）
	1. 初始化包级别的变量
	2. init函数，一个包中每个.go源文件都可以有多个init函数
17. 生命周期和作用域是两个截然不同的概念，生命周期是一个运行时概念，而作用域是一个编译时概念
18. 当局部变量和包级别变量重名时，会优先使用局部变量
19. 一个大括号围起来的一个语句序列叫做语法块。语法块内部声明的变量对外部不可见，但是对内部却是可见的。所以可以有下列情况：
```golang
// 虽然在短短的几行代码中，3次声明了x变量，但是并没有错误，它们3个处于不同的语法块中
// 每次声明时都要使用右边的表达式，而x在当时却未声明，所以=左边使用的是外层的x，而同级语法块内部使用的是刚声明的x
x := "hello!"
for i := 0; i < len(x); i++ {
	x := x[i]
	if x != '!' {
		x := x + 'A' - 'a'
		fmt.Printf("%c\n", x)
	}
}
``` 

20. if、switch、for等条件控制语句会创建一个隐式语法块，这个隐式语法块中的局部变量在整个控制结构中都能够使用，如：
```golang
if x := f(); x > 3 {
	xxxx
}else {
	// 无论在if还是在else中x都可以使用
	xxxx
}

// 同理，switch结构也可以

switch x := f(); x {
case x > 90 :
	xxxx
case x < 90 :
	xxxx
default :
	// 无论在哪一个case，x都可以使用
	xxxx
}
// 更有甚者，如下方所示

if x := f(); x > 3 {
	xxxxx
} else if y := g(x); x == y { // 使用if隐式语法域中的x作为参数，产生新的变量y
	xxxxx
	// 在这个分支以下的所有分支都可以使用y，但是在这个分支以上的分支不能使用y
}

```

21. 包级别的函数和常量、变量等声明没有先后顺序，前边的可以调用后边的
22. golang的数据类型
	1. 基础类型
		+ 数字
		+ 字符串
		+ 布尔类型
	2. 聚合类型
		+ 结构体
		+ 数组
	3. 引用类型
		+ 切片
		+ 字典
		+ 指针
		+ 通道
	4. 接口类型
		+ 接口
golang的整型分为`int8 int16 int32 int64 uint8 uint16 uint32 uint64 int uint`，其中int和uint对应于不同的硬件平台使用的大小也不同，等于该平台上运算效率最高的值。
rune是int32的同义词，两个名称可以互换使用，4个字节用来存储Unicode码点。
uintptr是无符号整数，用来存储指针类型，其大小并不明确，仅仅用于底层编程
int和uint的大小并不明确，尽管大多时候大小都等于int32，但是运算时必须进行显式的类型转换
