1. 有一些依赖工具会在包导入路径之后添加版本号后缀。如：`import "gopkg.in/yaml.v2"`，在使用时不用理会版本号，因为**包名不包含版本后缀**
2. 如果导入的包两个及以上存在重名包，要对包名进行重命名（如果包名太过冗长，也可以进行重命名）
3. 因为golang不允许存在包导入之后没有被使用的情况，但有时又不得不导入一个包（使用这个包的init函数初始化一些东西，也会执行这个包的包级别变量和函数初始化），此时可以使用匿名变量
4. 如果go run时有参数，以第一个不以.go结尾的参数开始解析参数
5. `// +build ignore` 在.go源文件第一句写这个文档注释，在任何情况下都不会对其进行编译；`// +build linux xxx`只会在linux平台上进行编译（也不是强制要求linux系统，只要GOARCH=linux就可以）
6. 比较长的注释可以单独起一个文档，命名为doc.go
7. `go doc xxx`，如xxx=fmt或fmt.Println可以通过`go doc`命令查看包注释或函数注释(方法注释也可以)
8. 如果一个包被导出，则这个包内的所有可导出变量和函数都是可以被外界访问的，此时，可以将包定义`internal`路径下，如果一个包的导入路径包含有internal，那么这个包只能被internal目录的父目录下的包导入。
```txt
包1：net/http/internal/chunked			// internal目录的父目录：net/http
包2：net/http/httputil				// 所以包2可以导入包1
包3：net/url					// 不行，包3不在net/http目录下
```

9. `go list xxx` 查看xxx包是否存在于当前工作空间，`go list ...`查看当前工作空间中所有包（包括导入包）

---

10. 在包目录中，以_test.go结尾的文件不是go build命令编译的目标。而是go test编译的目标
11. _test.go结尾的文件中有三种特殊的函数：
	1. 功能测试函数，以Test前缀命名
	2. 基准测试函数，以Benchmark前缀命名
	3. 示例函数，以Example前缀命名
11.1 测试文件同样要声明package，在哪个包下就声明哪个包（即同一目录下的包名是一致的），在测试时，main包等同于普通包。测试结果Fail或Pass在于是否手动调用t.Error()或t.Errorf()报错，不主动调用的话将永远正确（无意义）
11.2 如果一个_test.go文件包含多个测试函数，执行go test将执行这个包下的所有测试函数并输入结果Fail或Pass，但并不显示哪个函数没有通过，加-v参数将显示每个测试函数的执行时间和通过情况。执行go test -run="xxx|xxx"将正则匹配那些满足xxx或xxx的函数执行（正经测试时要执行所有的函数，不要只测试部分函数）

```golang
// 测试文件必须导入testing包
func TestName(t *testing.T){
	xxxx
}
```

11.3 如果包1导入了包2，并且现在在包2的测试文件中又要使用包1，如果直接写的话会形成循环依赖，陷入死循环。此时可以使用外部包。所谓外部包，因为大多数情况下，我们声明一个测试文件的包都是所在目录的包，而外部包就是单独写一个包声明(以_test为后缀的包名)，并不和所在目录一致，再在文件中引入包1、包2。

